##10 . java垃圾回收与内存分配策略
        10.1 垃圾回收是什么？
             释放那些不再持有引用的对象所占用的内存
        10.2 怎么判断一个对象是否需要回收
             * 引用计数（最简单古老的方法): 指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放.
             * 对象引用遍历（现在大多数 jvm 使用的方法）: 对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。
               如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集.
             * 引用计数缺陷：引用计数无法解决循环引用问题：假设对象A，B都已经被实例化，让A=B,B=A,除此之外这两个对象再无任何引用，此时计数器的值就永远不可能为0，
               但是引用计数器无法通知gc回收他们  
        10.3 Java的四种引用的区别
              * 强引用：就是直接通过new方法示例化的对象引用，如果一个对象具有强引用，它就不好被垃圾回收器回收。即使当前内存不足，JVM也不会回收它，
                       而是抛出OutOfMemoryError错误，使程序异常终止。可以显式地将引用赋值为null，这样JVM会在合适的时候回收该对象。
              * 软引用：采用SoftReference包装过的引用，内存充足的时候，，软引用不会被JVM回收，只有当内存不足时，软引用才会被垃圾回收器回收。
              * 弱引用：具有弱引用的对象生命周期更短，当JVM进行垃圾回收，一旦发现弱引用对象，无论内存是否不足，弱引用都会被回收。
              * 虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。  
        10.4 介绍垃圾回收机制
              < 标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片
              < 标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率
              < 复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。
              < 分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，
                           对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法  

## 11. Java中堆和栈的区别
>    **堆** 一种通用的内存池，位于RAM区，用于存放所有的Java对象。   
>           *好处*：编译器不需要知道，存储在堆里的对象存活多久， 在堆里分配内存比较灵活，当需要一个对象时，只需要new一个出来，当执行到这段代码的时候，会自动在堆里进行内存分配。  
>           *坏处*：用堆进行内存分配和清理，要比用栈时间长。

>   **栈**    位于RAM里，存储速度仅次于寄存器，用来存储基本数据类型和Java的引用变量，以及局部变量。多线程的数据位于独立的栈里。  
>   *坏处*创建程序时，必须要知道存储在栈里所有数据项的生命周期，以便上下移动栈指针。  

##12. Java集合
>   

  